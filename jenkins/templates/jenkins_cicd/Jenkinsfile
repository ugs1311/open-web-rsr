def call() {
    pipeline {
        agent any

        parameters {
            string(name: 'GITHUB_REPO', defaultValue: 'https://github.com/ugs1311/open-web-rsr.git', description: 'GitHub Repository URL')
            string(name: 'DOCKERHUB_USERNAME', defaultValue: credentials('docker-hub-credentials').username, description: 'Docker Hub Username')
            string(name: 'MINIKUBE_NAMESPACE', defaultValue: 'default', description: 'Minikube Namespace')
            choice(name: 'ENVIRONMENT', choices: ['dev', 'staging', 'prod'], description: 'Deployment Environment')
        }

        environment {
            GITHUB_CREDS = credentials('github-credentials')
            DOCKER_CREDS = credentials('docker-hub-credentials')
            ARGOCD_CREDS = credentials('argocd-credentials')
            IMAGE_NAME = 'open-web-rsr'
            IMAGE_TAG = "${BUILD_NUMBER}"
            DOCKER_REGISTRY = 'docker.io'
        }

        stages {
            stage('Checkout Source') {
                steps {
                    checkout scm
                }
            }

            stage('Run Tests') {
                steps {
                    sh '''
                        python -m pip install --upgrade pip
                        pip install -r requirements.txt
                        python -m pytest tests/ --junitxml=test-results.xml
                    '''
                }
            }

            stage('Build Docker Image') {
                steps {
                    script {
                        docker.withRegistry('https://index.docker.io/v1/', 'docker-hub-credentials') {
                            def customImage = docker.build("${DOCKER_REGISTRY}/${DOCKER_CREDS_USR}/${IMAGE_NAME}:${IMAGE_TAG}")
                            customImage.push()
                            customImage.push('latest')
                        }
                    }
                }
            }

            stage('Test Docker Image') {
                steps {
                    sh """
                        docker run --rm ${DOCKER_REGISTRY}/${DOCKER_CREDS_USR}/${IMAGE_NAME}:${IMAGE_TAG} python -m pytest tests/
                    """
                }
            }

            stage('Deploy to Minikube') {
                when {
                    expression { params.ENVIRONMENT != 'prod' }
                }
                steps {
                    sh """
                        kubectl config use-context minikube
                        kubectl create namespace ${params.MINIKUBE_NAMESPACE} || true
                        
                        # Update deployment image
                        sed -i 's|image: .*|image: ${DOCKER_REGISTRY}/${DOCKER_CREDS_USR}/${IMAGE_NAME}:${IMAGE_TAG}|' k8s/deployment.yaml
                        
                        # Apply Kubernetes manifests
                        kubectl apply -f k8s/ -n ${params.MINIKUBE_NAMESPACE}
                    """
                }
            }

            stage('Deploy to Production') {
                when {
                    expression { params.ENVIRONMENT == 'prod' }
                }
                steps {
                    input message: 'Deploy to production?'
                    sh """
                        argocd login ${ARGOCD_SERVER} --username ${ARGOCD_CREDS_USR} --password ${ARGOCD_CREDS_PSW} --insecure
                        argocd app set ${IMAGE_NAME} --kustomize-image ${DOCKER_REGISTRY}/${DOCKER_CREDS_USR}/${IMAGE_NAME}:${IMAGE_TAG}
                        argocd app sync ${IMAGE_NAME}
                        argocd app wait ${IMAGE_NAME}
                    """
                }
            }

            stage('Testing After Deployment') {
                steps {
                    script {
                        def namespace = params.MINIKUBE_NAMESPACE
                        def serviceName = "${IMAGE_NAME}-service"
                        
                        // Wait for deployment
                        sh "kubectl rollout status deployment/${IMAGE_NAME} -n ${namespace}"
                        
                        // Get service URL
                        def serviceUrl = sh(
                            script: "minikube service ${serviceName} -n ${namespace} --url",
                            returnStdout: true
                        ).trim()
                        
                        // Run health check
                        sh "curl -f ${serviceUrl}/health || exit 1"
                    }
                }
            }
        }

        post {
            always {
                junit 'test-results.xml'
                cleanWs()
            }
            success {
                echo 'Pipeline completed successfully!'
            }
            failure {
                echo 'Pipeline failed!'
            }
        }
    }
}

return this
